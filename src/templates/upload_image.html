<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>画像編集 - ぼかし処理ツール</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <link href="{{ url_for('static', path='/css/styles.css') }}" rel="stylesheet">
  </head>
  <body class="container py-4">
    <h1 class="mb-4">画像ぼかしツール</h1>

    <div class="usage-guide mb-4">
      <div class="usage-header" data-bs-toggle="collapse" data-bs-target="#usageContent" aria-expanded="false" aria-controls="usageContent">
        <h5 class="mb-0">
          <i class="bi bi-info-circle me-2"></i>使い方
          <i class="bi bi-chevron-down float-end"></i>
        </h5>
      </div>
      <div class="collapse" id="usageContent">
        <div class="usage-body">
          <ol>
            <li>「画像を選択」ボタンをクリックして、編集したい画像をアップロードします。</li>
            <li>画像上でマウスをドラッグして、ぼかしを適用したい範囲を選択します。</li>
            <li>選択した範囲に自動的にぼかし処理が適用されます。</li>
            <li>必要に応じて以下の操作を行えます：
              <ul>
                <li>「1つ前に戻す」: 直前のぼかし処理を取り消します</li>
                <li>「クリア」: すべてのぼかし処理をリセットします</li>
                <li>「画像をダウンロード」: 編集した画像を保存します</li>
              </ul>
            </li>
          </ol>
        </div>
      </div>
    </div>

    <div class="d-flex align-items-center">
      <form id="uploadForm" action="/upload" enctype="multipart/form-data" method="post">
        <div class="file-upload">
          <label class="file-upload-label">
            画像を選択
            <input id="fileInput" name="file" type="file" accept="image/*" onchange="document.getElementById('uploadForm').submit()">
          </label>
        </div>
      </form>

      <div class="alert alert-info mb-0 ms-3" role="alert" style="background: none; border: none;">
        {{ file_name }}
      </div>
    </div>
    
    <div class="canvas-container">
      <div class="button-container">
        <button class="btn btn-action" onclick="clearCanvas()" id="clearButton" disabled>
          <i class="bi bi-arrow-counterclockwise"></i> クリア
        </button>
        <button class="btn btn-undo" onclick="undoLastAction()" id="undoButton" disabled>
          <i class="bi bi-arrow-left"></i> 1つ前に戻す
        </button>
        <button class="btn btn-download" onclick="downloadImage()" id="downloadButton" disabled>
          <i class="bi bi-download"></i> 画像をダウンロード
        </button>
        <div class="processing-indicator" id="processingIndicator">処理中...</div>
        <div class="color-select-container">
          <div class="color-select-button" onclick="toggleColorDropdown()">
            <div class="color-sample" id="selectedColorSample"></div>
          </div>
          <div class="color-select-dropdown" id="colorDropdown">
            <div class="color-option" onclick="selectColor('#FF0000')">
              <div class="color-sample" style="background-color: #FF0000;"></div>
            </div>
            <div class="color-option" onclick="selectColor('#FFFF00')">
              <div class="color-sample" style="background-color: #FFFF00;"></div>
            </div>
            <div class="color-option" onclick="selectColor('#00FFFF')">
              <div class="color-sample" style="background-color: #00FFFF;"></div>
            </div>
            <div class="color-option" onclick="selectColor('#FFFFFF')">
              <div class="color-sample" style="background-color: #FFFFFF;"></div>
            </div>
            <div class="color-option" onclick="selectColor('#000000')">
              <div class="color-sample" style="background-color: #000000;"></div>
            </div>
            <div class="color-option" onclick="selectColor('#00FF00')">
              <div class="color-sample" style="background-color: #00FF00;"></div>
            </div>
          </div>
        </div>
      </div>
      <canvas id="imageCanvas"></canvas>
    </div>

    <!-- エラーモーダル -->
    <div class="modal fade" id="errorModal" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="errorModalLabel">エラー</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="alert alert-danger mb-0">
              <i class="bi bi-exclamation-triangle-fill me-2"></i>
              <span id="errorMessage"></span>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">閉じる</button>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      // エラーモーダルを表示する関数
      function showError(message) {
        document.getElementById('errorMessage').textContent = message;
        const errorModal = new bootstrap.Modal(document.getElementById('errorModal'));
        errorModal.show();
      }

      // 色選択の関数
      let selectedColor = '#FF0000';
      
      function toggleColorDropdown() {
        const dropdown = document.getElementById('colorDropdown');
        dropdown.classList.toggle('show');
      }

      function selectColor(color) {
        selectedColor = color;
        document.getElementById('selectedColorSample').style.backgroundColor = color;
        document.getElementById('colorDropdown').classList.remove('show');
      }

      // クリック以外の場所をクリックした時にドロップダウンを閉じる
      window.addEventListener('click', function(e) {
        if (!e.target.closest('.color-select-container')) {
          document.getElementById('colorDropdown').classList.remove('show');
        }
      });

      // 初期色を設定
      document.getElementById('selectedColorSample').style.backgroundColor = selectedColor;

      const canvas = document.getElementById('imageCanvas');
      if (canvas) {
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let startX = 0;
        let startY = 0;
        let currentX = 0;
        let currentY = 0;
        let imageData = null;
        let originalImageData = null;
        let selectedRect = null;
        let imageHistory = [];
        let scale = 1;

        function updateCanvasWithImage(imgSrc, isInitialLoad = false) {
          const newImg = new Image();
          newImg.onload = function() {
            canvas.width = newImg.width;
            canvas.height = newImg.height;
            ctx.drawImage(newImg, 0, 0);
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            if (isInitialLoad) {
              originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              imageHistory = [ctx.getImageData(0, 0, canvas.width, canvas.height)];
              document.getElementById('clearButton').disabled = true;
            }
            selectedRect = null;
            scale = canvas.width / canvas.getBoundingClientRect().width;
          };
          newImg.src = imgSrc;
        }

        const fileContent = "{{ file_content|safe if file_content else '' }}";
        const contentType = "{{ content_type if content_type else '' }}";
        if (fileContent && contentType) {
          updateCanvasWithImage(`data:${contentType};base64,${fileContent}`, true);
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        function getScaledCoordinates(e) {
          const rect = canvas.getBoundingClientRect();
          return {
            x: (e.clientX - rect.left) * scale,
            y: (e.clientY - rect.top) * scale
          };
        }

        function startDrawing(e) {
          isDrawing = true;
          const coords = getScaledCoordinates(e);
          startX = coords.x;
          startY = coords.y;
          currentX = startX;
          currentY = startY;
          selectedRect = null;
        }

        function draw(e) {
          if (!isDrawing) return;
          
          const coords = getScaledCoordinates(e);
          currentX = coords.x;
          currentY = coords.y;
          
          ctx.putImageData(imageData, 0, 0);
          
          if (isDrawing) {
            // 選択された色で実線を描画
            ctx.strokeStyle = selectedColor;
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.rect(startX, startY, currentX - startX, currentY - startY);
            ctx.stroke();
          }
        }

        function stopDrawing() {
          if (isDrawing) {
            selectedRect = {
              x: Math.min(startX, currentX),
              y: Math.min(startY, currentY),
              width: Math.abs(currentX - startX),
              height: Math.abs(currentY - startY)
            };
            
            ctx.putImageData(imageData, 0, 0);
            
            if (selectedRect.width > 0 && selectedRect.height > 0) {
              applyBlur();
            }
          }
          isDrawing = false;
        }

        function clearCanvas() {
          if (originalImageData) {
            ctx.putImageData(originalImageData, 0, 0);
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            selectedRect = null;
            
            imageHistory = [];
            document.getElementById('undoButton').disabled = true;
            document.getElementById('downloadButton').disabled = true;
            document.getElementById('clearButton').disabled = true;
          }
        }

        function undoLastAction() {
          if (imageHistory.length > 0) {
            const lastState = imageHistory.pop();
            ctx.putImageData(lastState, 0, 0);
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            if (imageHistory.length === 0) {
              document.getElementById('undoButton').disabled = true;
              document.getElementById('downloadButton').disabled = true;
              document.getElementById('clearButton').disabled = true;
            }
          }
        }

        function applyBlur() {
          if (!selectedRect) {
            alert('ぼかす領域を選択してください');
            return;
          }

          imageHistory.push(ctx.getImageData(0, 0, canvas.width, canvas.height));

          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = selectedRect.width;
          tempCanvas.height = selectedRect.height;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(canvas,
            selectedRect.x, selectedRect.y, selectedRect.width, selectedRect.height,
            0, 0, selectedRect.width, selectedRect.height
          );

          const processingIndicator = document.getElementById('processingIndicator');
          processingIndicator.style.display = 'inline-flex';

          tempCanvas.toBlob(function(blob) {
            const formData = new FormData();
            formData.append('image', blob);

            fetch('/apply_blur', {
              method: 'POST',
              body: formData
            })
            .then(response => {
              if (!response.ok) {
                return response.json().then(data => {
                  throw new Error(data.error || 'ぼかし処理中にエラーが発生しました');
                });
              }
              return response.blob();
            })
            .then(blob => {
              const url = URL.createObjectURL(blob);
              const blurredImg = new Image();
              blurredImg.onload = function() {
                ctx.putImageData(imageData, 0, 0);
                ctx.drawImage(blurredImg, selectedRect.x, selectedRect.y);
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                document.getElementById('undoButton').disabled = false;
                document.getElementById('downloadButton').disabled = false;
                document.getElementById('clearButton').disabled = false;
                processingIndicator.style.display = 'none';
              };
              blurredImg.src = url;
            })
            .catch(error => {
              console.error('Error:', error);
              showError(error.message);
              imageHistory.pop();
              processingIndicator.style.display = 'none';
            });
          }, 'image/png');
        }

        function downloadImage() {
          const dataURL = canvas.toDataURL('image/png');
          
          const originalName = '{{ file_name }}';
          const lastDotIndex = originalName.lastIndexOf('.');
          const newFileName = lastDotIndex !== -1
            ? originalName.substring(0, lastDotIndex) + '_blurred' + originalName.substring(lastDotIndex)
            : originalName + '_blurred';
          
          const link = document.createElement('a');
          link.download = newFileName;
          link.href = dataURL;
          
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        window.addEventListener('resize', function() {
          scale = canvas.width / canvas.getBoundingClientRect().width;
        });
      }
    </script>
  </body>
</html>
