<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>アップロードされた画像</title>
    <style>
      .canvas-container {
        position: relative;
        display: inline-block;
      }
      #imageCanvas {
        border: 1px solid #ccc;
      }
      .button-container {
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <form id="uploadForm" action="/upload" enctype="multipart/form-data" method="post">
      <input id="fileInput" name="file" type="file" accept="image/*" onchange="document.getElementById('uploadForm').submit()">
    </form>
    <p>アップロードされたファイル名: {{ file_name }}</p>
    
    <div class="button-container">
      <button onclick="clearCanvas()">クリア</button>
    </div>

    <div class="canvas-container">
      <canvas id="imageCanvas"></canvas>
    </div>

    <script>
      const canvas = document.getElementById('imageCanvas');
      const ctx = canvas.getContext('2d');
      let isDrawing = false;
      let startX = 0;
      let startY = 0;
      let currentX = 0;
      let currentY = 0;
      let imageData = null;
      let originalImageData = null;
      let selectedRect = null;

      function updateCanvasWithImage(imgSrc, isInitialLoad = false) {
        const newImg = new Image();
        newImg.onload = function() {
          canvas.width = newImg.width;
          canvas.height = newImg.height;
          ctx.drawImage(newImg, 0, 0);
          imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          if (isInitialLoad) {
            originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          }
          selectedRect = null;
        };
        newImg.src = imgSrc;
      }

      // 初期画像の読み込み
      updateCanvasWithImage("data:{{ content_type }};base64,{{ file_content }}", true);

      // マウスイベントの処理
      canvas.addEventListener('mousedown', startDrawing);
      canvas.addEventListener('mousemove', draw);
      canvas.addEventListener('mouseup', stopDrawing);
      canvas.addEventListener('mouseout', stopDrawing);

      function startDrawing(e) {
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        currentX = startX;
        currentY = startY;
        selectedRect = null;
      }

      function draw(e) {
        if (!isDrawing) return;
        
        const rect = canvas.getBoundingClientRect();
        currentX = e.clientX - rect.left;
        currentY = e.clientY - rect.top;
        
        // 前回の描画をクリア
        ctx.putImageData(imageData, 0, 0);
        
        // ドラッグ中のみ選択範囲を表示
        if (isDrawing) {
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(startX, startY, currentX - startX, currentY - startY);
          ctx.stroke();
        }
      }

      function stopDrawing() {
        if (isDrawing) {
          selectedRect = {
            x: Math.min(startX, currentX),
            y: Math.min(startY, currentY),
            width: Math.abs(currentX - startX),
            height: Math.abs(currentY - startY)
          };
          
          // 選択範囲の枠を消す
          ctx.putImageData(imageData, 0, 0);
          
          // 選択範囲が有効な場合のみブラー処理を実行
          if (selectedRect.width > 0 && selectedRect.height > 0) {
            applyBlur();
          }
        }
        isDrawing = false;
      }

      function clearCanvas() {
        if (originalImageData) {
          ctx.putImageData(originalImageData, 0, 0);
          imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          selectedRect = null;
        }
      }

      function applyBlur() {
        if (!selectedRect) {
          alert('ぼかす領域を選択してください');
          return;
        }

        // 選択領域のみを切り出し
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = selectedRect.width;
        tempCanvas.height = selectedRect.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(canvas,
          selectedRect.x, selectedRect.y, selectedRect.width, selectedRect.height,
          0, 0, selectedRect.width, selectedRect.height
        );

        // 切り出した領域のみをBlob形式で送信
        tempCanvas.toBlob(function(blob) {
          const formData = new FormData();
          formData.append('image', blob);

          fetch('/apply_blur', {
            method: 'POST',
            body: formData
          })
          .then(response => response.blob())
          .then(blob => {
            const url = URL.createObjectURL(blob);
            const blurredImg = new Image();
            blurredImg.onload = function() {
              // 元の画像データを復元
              ctx.putImageData(imageData, 0, 0);
              // ブラー処理された領域を貼り付け
              ctx.drawImage(blurredImg, selectedRect.x, selectedRect.y);
              // 現在の状態を保存
              imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            };
            blurredImg.src = url;
          })
          .catch(error => {
            console.error('Error:', error);
            alert('ぼかし処理中にエラーが発生しました');
          });
        }, 'image/png');
      }
    </script>
  </body>
</html>
