<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>画像編集 - ぼかし処理ツール</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
      .canvas-container {
        position: relative;
        display: inline-block;
        margin: 20px 0;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
        border-radius: 4px;
        overflow: hidden;
      }
      #imageCanvas {
        display: block;
        max-width: 100%;
        height: auto;
      }
      .button-container {
        margin: 20px 0;
      }
      .file-upload {
        position: relative;
        display: inline-block;
        margin: 20px 0;
      }
      .file-upload-label {
        display: inline-block;
        padding: 10px 20px;
        background: #007bff;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.3s;
      }
      .file-upload-label:hover {
        background: #0056b3;
      }
      .file-upload input[type="file"] {
        position: absolute;
        left: 0;
        top: 0;
        opacity: 0;
        cursor: pointer;
      }
    </style>
  </head>
  <body class="container py-4">
    <h1 class="mb-4">画像ぼかしツール</h1>

    <form id="uploadForm" action="/upload" enctype="multipart/form-data" method="post">
      <div class="file-upload">
        <label class="file-upload-label">
          画像を選択
          <input id="fileInput" name="file" type="file" accept="image/*" onchange="document.getElementById('uploadForm').submit()">
        </label>
      </div>
    </form>

    <div class="alert alert-info" role="alert">
      アップロードされたファイル: {{ file_name }}
    </div>
    
    <div class="button-container">
      <button class="btn btn-secondary me-2" onclick="clearCanvas()">
        <i class="bi bi-arrow-counterclockwise"></i> クリア
      </button>
      <button class="btn btn-warning me-2" onclick="undoLastAction()" id="undoButton" disabled>
        <i class="bi bi-arrow-left"></i> 1つ前に戻す
      </button>
      <button class="btn btn-primary" onclick="downloadImage()" id="downloadButton" disabled>
        <i class="bi bi-download"></i> 画像をダウンロード
      </button>
    </div>

    <div class="canvas-container">
      <canvas id="imageCanvas"></canvas>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      const canvas = document.getElementById('imageCanvas');
      if (canvas) {
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let startX = 0;
        let startY = 0;
        let currentX = 0;
        let currentY = 0;
        let imageData = null;
        let originalImageData = null;
        let selectedRect = null;
        let imageHistory = [];
        let scale = 1;

        function updateCanvasWithImage(imgSrc, isInitialLoad = false) {
          const newImg = new Image();
          newImg.onload = function() {
            canvas.width = newImg.width;
            canvas.height = newImg.height;
            ctx.drawImage(newImg, 0, 0);
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            if (isInitialLoad) {
              originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              imageHistory = [ctx.getImageData(0, 0, canvas.width, canvas.height)];
            }
            selectedRect = null;
            // スケールを計算
            scale = canvas.width / canvas.getBoundingClientRect().width;
          };
          newImg.src = imgSrc;
        }

        const fileContent = "{{ file_content|safe if file_content else '' }}";
        const contentType = "{{ content_type if content_type else '' }}";
        if (fileContent && contentType) {
          updateCanvasWithImage(`data:${contentType};base64,${fileContent}`, true);
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        function getScaledCoordinates(e) {
          const rect = canvas.getBoundingClientRect();
          return {
            x: (e.clientX - rect.left) * scale,
            y: (e.clientY - rect.top) * scale
          };
        }

        function startDrawing(e) {
          isDrawing = true;
          const coords = getScaledCoordinates(e);
          startX = coords.x;
          startY = coords.y;
          currentX = startX;
          currentY = startY;
          selectedRect = null;
        }

        function draw(e) {
          if (!isDrawing) return;
          
          const coords = getScaledCoordinates(e);
          currentX = coords.x;
          currentY = coords.y;
          
          ctx.putImageData(imageData, 0, 0);
          
          if (isDrawing) {
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.rect(startX, startY, currentX - startX, currentY - startY);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        }

        function stopDrawing() {
          if (isDrawing) {
            selectedRect = {
              x: Math.min(startX, currentX),
              y: Math.min(startY, currentY),
              width: Math.abs(currentX - startX),
              height: Math.abs(currentY - startY)
            };
            
            ctx.putImageData(imageData, 0, 0);
            
            if (selectedRect.width > 0 && selectedRect.height > 0) {
              applyBlur();
            }
          }
          isDrawing = false;
        }

        function clearCanvas() {
          if (originalImageData) {
            ctx.putImageData(originalImageData, 0, 0);
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            selectedRect = null;
            
            imageHistory = [];
            document.getElementById('undoButton').disabled = true;
            document.getElementById('downloadButton').disabled = true;
          }
        }

        function undoLastAction() {
          if (imageHistory.length > 0) {
            const lastState = imageHistory.pop();
            ctx.putImageData(lastState, 0, 0);
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            if (imageHistory.length === 0) {
              document.getElementById('undoButton').disabled = true;
              document.getElementById('downloadButton').disabled = true;
            }
          }
        }

        function applyBlur() {
          if (!selectedRect) {
            alert('ぼかす領域を選択してください');
            return;
          }

          imageHistory.push(ctx.getImageData(0, 0, canvas.width, canvas.height));

          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = selectedRect.width;
          tempCanvas.height = selectedRect.height;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(canvas,
            selectedRect.x, selectedRect.y, selectedRect.width, selectedRect.height,
            0, 0, selectedRect.width, selectedRect.height
          );

          tempCanvas.toBlob(function(blob) {
            const formData = new FormData();
            formData.append('image', blob);

            fetch('/apply_blur', {
              method: 'POST',
              body: formData
            })
            .then(response => response.blob())
            .then(blob => {
              const url = URL.createObjectURL(blob);
              const blurredImg = new Image();
              blurredImg.onload = function() {
                ctx.putImageData(imageData, 0, 0);
                ctx.drawImage(blurredImg, selectedRect.x, selectedRect.y);
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                document.getElementById('undoButton').disabled = false;
                document.getElementById('downloadButton').disabled = false;
              };
              blurredImg.src = url;
            })
            .catch(error => {
              console.error('Error:', error);
              alert('ぼかし処理中にエラーが発生しました');
              imageHistory.pop();
            });
          }, 'image/png');
        }

        function downloadImage() {
          const dataURL = canvas.toDataURL('image/png');
          
          const originalName = '{{ file_name }}';
          const lastDotIndex = originalName.lastIndexOf('.');
          const newFileName = lastDotIndex !== -1
            ? originalName.substring(0, lastDotIndex) + '_blurred' + originalName.substring(lastDotIndex)
            : originalName + '_blurred';
          
          const link = document.createElement('a');
          link.download = newFileName;
          link.href = dataURL;
          
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        // ウィンドウリサイズ時にスケールを更新
        window.addEventListener('resize', function() {
          scale = canvas.width / canvas.getBoundingClientRect().width;
        });
      }
    </script>
  </body>
</html>
